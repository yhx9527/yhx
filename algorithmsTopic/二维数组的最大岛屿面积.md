# 给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。  
找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)

示例 1:

[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]  
对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。

示例 2:

[[0,0,0,0,0,0,0,0]]
对于上面这个给定的矩阵, 返回 0。

注意: 给定的矩阵grid 的长度和宽度都不超过 50。

思路：  
题目求的就是最多相邻的1有几个，还是比较明显能看出是某种寻路算法。再想想我们平常如果是手算，按照比较有规律的情况下，很显然就是先一条路走到通，然后再往其他处扩展。这种思想呢就是DFS（深度优先遍历）了。那要怎么实现呢。  

首先我们观察一下深度优先遍历的特点，有没有发现它其实每次只往同一个方向一直找，直到找到最后没有了才回退一步往另一个方向。往一个方向一直找的过程就是一个递归，而回退一步呢就是回溯。  

先思考到这里，我们看题，题目要在矩阵中查找，很明显遍历二维数组找到一个合适元素（即a[i][j] ===1 ）时，他可以往上右下左四个方向继续找，然后往上找到之后，找到的这个元素又可以往上右下左去找，找不到就回退一步换个方向往右去找，画成我们的递归楼层便是  

上右下左  
...  
上右下左  
上右下左  
上右下左  

**就像上面的可以总结DFS的一个特点：查找方向不变的‘盖房子’递归**

同时比如当我们从一个元素a找到另一个元素b,然后又要从b上右下左开始找，这时不该再找到a了，所以有什么办法呢，一开始我想的是通过一个set集合，每次进行路径查找时记录找过的坐标，这样找到之后就可以判断。这样是ok的，不过略显麻烦，我们再想想我们使用set的原因就是让他不要遍历已经走过的节点，然后我们看我们进入递归的条件是查找的值大于0，想到这里应该就可以知道怎么改了，那就是找完一个节点之后，便把它置0，这样它下次就不会再被找到。  
其实这一点也是整体优化的关键，我一开始没想到，写的就是代码一，结果通过是通过了，不过时间居然7-8s，我滴天。然后修改一下采用刚才的方法，就是代码二，哈哈轻轻松松100ms左右。

```
//代码一
var maxAreaOfIsland = function(grid) {
	var maxarea=0,i,j,set=new Set(),area=0;
	for(i=0;i<grid.length;i++)
		for(j=0;j<grid[i].length;j++){
			set.clear();
			area=0;
			if(grid[i][j] > 0){
				dfs(i,j);
			}
		maxarea = Math.max(maxarea, area);
	}

	function dfs(i,j){
		if(i>=0 && i<grid.length && j>=0 && j<grid[i].length){
			if(grid[i][j] > 0 && !set.has(i+','+j)){
				area++;
				set.add(i+','+j)
				dfs(i-1,j);
				dfs(i,j+1);
				dfs(i+1,j);
				dfs(i,j-1);
			}else{
				return;
			}
		}
	}
	   		return maxarea;
    };
```

```
//代码二
var maxAreaOfIsland = function(grid) {
	var maxarea=0,i,j,area=0;
	for(i=0;i<grid.length;i++)
		for(j=0;j<grid[i].length;j++){
			area=0;
			if(grid[i][j] > 0){
				area = dfs(i,j);
			}
		maxarea = Math.max(maxarea, area);
	}

	function dfs(i,j){
		if(i>=0 && i<grid.length && j>=0 && j<grid[i].length){
			if(grid[i][j] > 0){
				grid[i][j]=0;
				return 1+dfs(i-1,j)+dfs(i,j+1)+dfs(i+1,j)+dfs(i,j-1);
			}else{
				return 0;
			}
		}
        return 0;
	}
	   		return maxarea;
    };
```

