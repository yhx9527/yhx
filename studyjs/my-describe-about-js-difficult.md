js中对象可以任意扩展属性的，引用类型都是对象
只有函数才有prototype这个属性
__proto__这个属性来自Object.prototype

原型：每个javaScript对象（除了null之外）在创建的时候都会有一个对象与之关联，这个对象是构造函数的prototype，也就是原型，每个实例都将继承这个原型里面的属性。原型这个对象在实例中的表示是隐式原型（__proto__）这个属性

原型链：在读取某个实例属性的时候，会现在他本身进行查找，如果没有则到它的原型上进行查找，再没有的话就到原型的原型找，一直找到Object.prototype这个原型，在没有得到话就没有了，这么一个查找的路径就是一条原型链

作用域:程序源代码中声明变量的区域,js采用的是静态作用域，即作用域是函数定义时就确定的了

作用域链:函数使用变量时的一个查找路径，具体查找步骤：
1. 首先在当前作用域下进行查找，找不到则到定义这个函数的作用域下进行查找 
2. 如果当前作用域是全局作用域，找不到则说明未定义
3. 若不是全局作用域则说明是函数作用域，则把这个作用域再当成当前作用域，在重复上述步骤进行查找

执行上下文：在执行代码前，会提前把需要用到的所有变量拿出来，有些直接赋值，有些先用undefined，这个准备工作就叫做执行上下文，其中执行上下文的管理是以栈的形式进行的。
其中直接赋值的有：函数声明，this，如果执行的是函数体的话还有arguments，函数参数等，（自由变量的取值作用域）
其中undefined占位的有普通变量，函数表达式，


EcmScript5规定的基本数据类型有Boolean，String,Number,Undefined,Null, 复杂数据类型Object
ES6引入了Symbol基本数据类型

基本数据类型是值类型，存放在栈中，有自己的内存，相互之间的比较是值的比较，类型不同会进行类型转换
Object是引用类型，具体的对象是存放在堆中，其标识符是在栈中，比较是引用（地址）的比较

typeof能返回的有undefined,boolean,string,number,object,function
instanceof用来检测一个实例是不是某个类型
其实沿着原型链看这个对象跟这个构造函数的原型有没有关系，其中instanceof左边对象沿着__proto__这条线去找关系，当它等于instanceof右边构造函数的prototype时返回true


this的使用场景：
1. 函数通过对象调用时，this指向该对象
2. 直接通过函数调用时，指向全局window
3. 构造函数中调用时，指向当前实例对象
4. 函数通过call，apply运行时，this指向传入的第一个参数对象
5. ES6中箭头函数中this在定义时就绑定了，绑定的是父执行上下文


闭包：能够访问自由变量的函数，这些函数即使创建它的上下文已经被销毁了，但它认可访问到上下文中的变量
闭包的应用：函数作为返回值，函数作为参数
自由变量：在函数中使用，但既不是函数参数也不是局部变量的变量