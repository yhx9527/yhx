# javaScript基础

标签（空格分隔）： 未分类

---
#### 原型规则 ##
- 所有的引用类型都可以任意扩展属性

- 所有的引用类型都有隐式原型__ proto __

- 函数类型才拥有显式原型prototype。该属性是一个对象，函数被声明时就被自动创建了

- 引用类型（arry，object，function）的隐式原型 === 于其构造函数的显式原型prototype，Object.prototype.__ proto__ 为null

- 查找某个对象的属性，先在它的身上找，找不到，再到它的__ proto __ （即它的构造函数的prototype）上找，再找不到，就在它的构造函数的prototype的__ proto __上找，一层一层往上直到找到Object.prototype. __ proto __,它是为null的，也就是没有这个属性（undefined）


---
new一个对象的过程:
1.新生成一个对象  
2.新对象链接到原型（xx.__ proto __ 指向构造函数的原型）  
3.绑定this（执行this.id = id等之类的操作）  
4.返回新对象（this）
  
---
- 显式原型中定义的只new一次，所有实例共享，如果定义在 构造函数中，则每次都new


词法作用域：在编码时就写在那里的了，编译之后某个变量该在哪个作用域就在哪个作用域，哪个作用域里有哪些变量，这些是不变的。

伪造/欺骗词法作用域例子:
1.eval() ->在函数中动态加入可执行代码
![eval修改作用域][1]


  [1]: https://raw.githubusercontent.com/yhx9527/yhx/master/picures/eval%E6%AC%BA%E9%AA%97%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F.PNG
  
2.with(){}函数用于省去了频繁写同一个变量 ->根据传进来的对象来凭空新建一个全新的作用域

 - o1中因为有a属性，故成功进行了赋值
 - o2中因为没有a属性，在非严格模式下，则自动创建了一个全局变量
 - with新建的作用域中，foo函数里是可以访问的
 

**为了性能，不要使用eval和with，原因：**

词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。
JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时） 。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时） 。
这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。
引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。

---
函数调用栈

this 不指向自身（一个对象foo.cout的属性，this.cout是访问不到的），也不指向词法作用域，不要跟词法作用域混淆了（词法作用域就是从里向外找某个变量）

**this绑定规则**  
1.默认绑定
    
    var a = 1
    function foo（）{
        console.log(this.a)
    }
    foo() //1

上述this默认绑定了全局对象

--- 

**this使用场景**  
1. 作为构造函数执行  
2. 作为对象属性执行
3. 作为普通函数执行
4. call，apply，bind

---
**执行上下文**



对于一段 script标签来说，在执行之前会先将其中定义的变量，函数声明（这个函数）提到前面去，其中变量先赋值为undefined 
对于一个函数，在执行之前，同理也将变量，函数声明提到前面，同时this，arguments也是提前弄好的

- 函数以声明的形式定义，可以先用
function fun(){}，这个函数整个在执行之前被提到前面去了  
- 函数以表达式的形式，不可以先用
var fun = function(){}，因为只是变量fun被提到前面去了  
因为一开始会是var fun = undefined，声明提升

