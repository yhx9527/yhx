# 头条算法练习，冲鸭 #

1. 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
-
思路：  
1. 暴力法  
依次找出每个子串，然后检查子串中是否有重复字符，不重复则比较和上一个的长度。  
子串(0<=i<j<=n),故需两个循环，然后可用set来看子串中是否有重复，之后用Math.max()取出较大值。
时间复杂度O(n*3)   
2. 滑动窗口
使用一个set集合，想象它在字符串上扩张，如果字符没有在set里，则将其加入同时right++同时记录和上次的长度比较下的最长的那个；如果字符已在set里了，则移除left处的字符同时left++  
3. 滑动窗口优化
使用map，想象它在字符串上扩张，如果字符没在map里，则right++，将<字符,它所在位置>存进去;如果字符在map里,则left变为取出的位置+1。  
ps.可以用数组代替map，其中int[26]用于字母'a'-'z'或'A'-'Z';int[128]用于ASCII码;int[256]用于扩展ASCII码

    var lengthOfLongestSubstring = function(s) {
    	var map = new Map(),i=j=0,large=0;
    	var len = s.length;
    	while(i<len && j<len){
    		if(map.has(s.charAt(j))){
       		i = Math.max((map.get(s.charAt(j))+1),i); 
    	}
    	large = Math.max(large,j-i+1);
    	map.set(s.charAt(j++),j-1);
    	}
    	return large;
    };

**待处理--> ES6 set,weekset,map,weekmap**

2. 编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。
-
思路：  
1. 取出第一个字符串作为初始前缀，然后与后面每一个字符串进行比对，不对从后面裁剪初始前缀，直到indexOf()==0为止  
2. 从第一行第一列的字符开始进行竖向比较，如果某一行的长度等于i或者不等于i列的某一行字符与第一行不同则结束循环。

    var longestCommonPrefix = function(strs) {
    	if(strs==null || strs.length < 1) return "";
    	var pre = strs[0]
    	for(var i=0;i<pre.length;i++){
    		var same = pre.charAt(i);
    		for(var j=1;j<strs.length;j++){
    		if(i==strs[j].length || same !== strs[j].charAt(i)){
    			return pre.substring(0,i)
    			}
   	 		}
    	}
    	return pre;
    };

3. 给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。换句话说，第一个字符串的排列之一是第二个字符串的子串。
-
思路:  
如果s2包含s1的全排列，则s2中必有一个子串长度等于s1同时s1中的每个字母的个数等于s2子串的每个字母的个数。所以先把s1字符串每个字母出现的个数记录在数组a中，然后遍历s2，找出是否存在s1长度的数组和a相等的

    var checkInclusion = function(s1, s2) {
    	if(s1.length > s2.length)return false;
    		var a1 = new Array(26).fill(0),a2 = new Array(26).fill(0),i,j;
    		for(i=0;i<s1.length;i++){
    			a1[s1.charCodeAt(i)-'a'.charCodeAt(0)] += 1;
    			a2[s2.charCodeAt(i)- 'a'.charCodeAt(0)] +=1;
    		}
    		for(j=0;j<=s2.length-s1.length;j++){
    			if(a1.toString()===a2.toString()){
    			return true
    		}
    		a2[s2.charCodeAt(j)-'a'.charCodeAt(0)] -=1;
    		a2[s2.charCodeAt(s1.length+j)-'a'.charCodeAt(0)] +=1;
    }
    	return false;
    };

4. 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
-
要求：  
1. num1 和 num2 的长度小于110。  
2. num1 和 num2 只包含数字 0-9。  
3. num1 和 num2 均不以零开头，除非是数字 0 本身。  
4. 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 

**//注意直接用parseInt转成整数的话计算精度是不够的**

思路：通过对乘法每一步的分析，我们可以发现   
	1.n位数与m位数相乘，最大为（n+m）位数  
    2.一个数的第i位与另一个数的第j位相乘，所放的位置是在[i+j,i+j-1]这里（可在纸上进行乘法分步运算看出）  
	3.最终的结果是分步的结果加起来  
    故我们可以用一个n+m长度的数组来存储每一步，如果存储的数组的每一位有值，则是加的关系，最后数组变成字符串即时最终结果。

    var multiply = function(num1, num2) {
    	if(num1==0 || num2==0){return '0'}
    	var len1=num1.length,len2=num2.length,i,j;
    	var len=len1+len2;
    	var arr = new Array(len).fill(0);
    	for(i=0;i<len1;i++){
    		var temp1=num1.charCodeAt(i)-'0'.charCodeAt(0);
    		for(j=0;j<len2;j++){
    			var temp2=num2.charCodeAt(j)-'0'.charCodeAt(0);
    			var sum=temp1*temp2;
    			arr[i+j+1]+=sum%10;
    			arr[i+j]+=Math.floor(sum/10);
    		}
    	}
    	for(var i=arr.length-1;i>0;i--){
    		if(arr[i]>9){
    			arr[i-1]+=Math.floor(arr[i]/10);
    			arr[i]%=10;
    		}
    	}
    	if(arr[0]==0){delete arr[0]}
    	return arr.join('')
    };

5. 给定一个字符串，逐个翻转字符串中的每个单词。
-
说明:

1. 无空格字符构成一个单词。  
2. 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。  
3. 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

思路：使用正则匹配先把两端的空格去掉，然后将字符串以空格来分割成数组，将数组反转，之后以一个空格来将数组变为字符串

    var reverseWords = function(str) {
    	if(str.length < 1) return "";
    	str = str.replace(/^\s*|\s*$/g,'')
    	if(str.length > 0){
    		str=str.split(/\s+/).reverse().join(' ')
    	}
    	return str;
    };

6. 给定一个文档 (Unix-style) 的完全路径，请进行路径简化。
-
例如，
path = "/home/", => "/home"
path = "/a/./b/../../c/", => "/c"

边界情况:  
你是否考虑了 路径 = "/../" 的情况？  
在这种情况下，你需返回 "/" 。  
此外，路径中也可能包含多个斜杠 '/' ，如 "/home//foo/" 。  
在这种情况下，你可忽略多余的斜杠，返回 "/home/foo" 。

思路：首先将字符串通过正则(一到多个'/')分割成数组a，准备好一个栈b（也就是一个新数组）,遍历a，如果元素存在且不为'.'接着判断，如果是'..'出栈，如果不是入栈，最后将栈b转为字符串，前面要加上'/'.

    var simplifyPath = function(path) {
    	var arr = path.split(/\/+/)
    	var stack=[]
    	arr.forEach(item=>{
    		if(item && item !== '.'){
    			if(item==='..'){
    				stack.pop()
    			}else{
    				stack.push(item)
    			}
    		}
    	})
    	return '/'+stack.join('/');
    };

7. 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。
-
思路：
先考虑IP地址的特点:   
1. IP地址有四段，每段在[0,255]的区间内，自然是要一段一段的确定，当确定好三段，第四段自然就确定了。  
2. 然后我们考虑，当第四段得出之后，如果不合适怎么办，肯定是要回到第三段调整，然后在接着第四段。同理，第三段不合适，肯定要回到第二段调整，一直到回到第一段。这个过程就是一个回溯的过程。  
3. 接着看怎么调整，调整肯定要写在调用递归函数之后了，调整的过程就是增加右边界。  
4. 最后补充一下进入的时候，左右边界要都要移到新的一块区域。  

    var restoreIpAddresses = function(s) {
    	var IPs=[];
    	var IP= [];
    	getIP(0,0,1);
    	function getIP(k,start,end){
    		var tempEnd = end;
    		var tempStart = start;
    		if(k===3){
    			var str=s.substring(start)
    			if(str){
    				if(parseInt(str) > 255 || (str.startsWith('0') && str.length > 1)) return;
    				IP.push(str);
    				IPs.push(IP.join('.'));
    				IP.pop();
    			}
    		}
    
    		for(var i=k;i<3;i++){
    			var str=s.substring(tempStart,tempEnd)
    			if(str){
    				if((tempEnd-tempStart)<=3 && parseInt(str) < 256 && (!str.startsWith('0') || str.length==1)){
    					IP.push(str);
    					getIP(k+1, tempStart+str.length,tempStart+str.length+1);
    					IP.pop()
    					i=k-1;
    					tempEnd += 1; 
    			}	
    			}
    
    		}
    	}
    	return IPs;
    };