# 2018-11-25记 #

1. 自我介绍  
面试官你们好，我叫余汉祥，来自电子科技大学信息与软件工程学院，目前大三。我大二的时候加入了学院的一个工作室，那时老师让我们做一个有关课堂签到督导的项目，我负责微信小程序这块，也正是这时我便开始我的前端学习。这个项目前前后后经过了半年，其中也上线了好几个版本，也在课堂上进行了好几次测试，每次测试后发现了问题我也在不断的完善。通过这个项目我觉得我最大的收获除了技术方面，了解了微信小程序整个地从开发到上线的流程以及前端的基础知识，还有就是另一方面就是业务能力，如何和同学进行沟通，和老师进行沟通，以及深入到小程序使用的学生那里了解到对于他们而言真正好用的签到小程序应该是怎么样的。在这个项目之后一个同学把我拉进了另一个项目组去也是去开发一个小程序，也就是我简历上写的“微言Talk”小程序，这个项目他们计划是要拿去参加明年的互联网+大赛的，所以在这之前需要累积影响力，这就要求了小程序要尽快开发出来并抓紧推广，时间比较紧。我决定用个小程序开发框架，上网搜过之后我选择了当前比较热门的wepy小程序框架，因为该框架是类Vue的开发模式，所以在这之前我也看了vue的一些基础知识，之后便开始了wepy小程序的开发，起初几天比较磕磕碰碰，对于组件化开发，组件之间的通信交互，事件处理比较陌生，不过随着开发地进行还是知道了这些东西，最后总算在两个礼拜之内完成了“微言Talk”小程序的开发并上线，项目老师还是比较满意的。之前的都是在开发小程序，虽然说对web也有一定了解，但还是似懂非懂，也正好同学找我帮忙做个web前端，于是我就想着趁此机会满足一下自己的web好奇心，也就是我简历上的第三个项目，是一个仓库管理系统，使用vue全家桶+element-ui开发，目前正在进行。项目的内容说的多了点，除了平常做项目，我也喜欢夜跑，看电影，玩玩游戏之类的。我算是一个不怎么内向也不怎么外向的人吧，生活上可以和同学朋友们开怀畅聊，工作学习中我总是秉着认真负责的态度。以上就是我的自我介绍，谢谢。

2. 项目难点
  1. 在跟踪用户会话方面，由于小程序没有cookie机制，所以我们没采用cookie和session配合的方式，采用的是token机制，使后端API可以适用于多种平台，如ios，android
  2. 签到小程序的有一个需求就是要防止代签的情况发生，防止学生登录多个学号进行签到。我们采取的一个方法就是将学生的学号和微信进行绑定，绑定完微信后，下次将自动登录，不能再切换学号。
  3. 因为签到我们采用的方案是限时定位签到，但每次测试的时候总有人因为定位问题签不成功，直到现在也是，经过几次的测试，我们总结一下：1.定位时有没有开启gps以及使用的网络类型是有关的，总的精确度来说 gps定位 > wifi精确度 > 移动网络精确度。所以我们提醒同学开启gps再去进行签到 
      2.关于定位，还有一点就是调用小程序的定位API刚开始的时候定位并不是很准的，得定个一两次才会稳定下来，所以我在开启小程序的时候加了个请求那个定位API的后台任务直到学生签到完成。
      3.除此之外，我们又提供了一个额外的拍照签到方式，让学生根据参照物照片进行拍摄发送到后台完成签到。
  4. 印象深刻的问题，也算不了很难的点-->小程序的textarea组件的一个bug，就是textarea组件的层级竟然是最高，这是在“微信Talk”小程序测试的时候发现的（因为有一个页面是有抽屉弹框的，textarea里面的文本却显示在最上面）当时还挺纳闷，明明没设置层级，检查了好几遍，后面在网上搜索才发现，原来是组件的一个bug，解决方法就是当有弹框之类出现时隐藏textarea，将里面的文本放在一个view里面，等弹窗关了再恢复。
  5. “微言Talk”小程序需要生成主题分享图进行传播，其中用canvas进行绘制没什么问题，就是微信小程序canvas绘制图片时在真机上是不支持base64图片的，可绘制的图片源可以是本地文件路径或者网络图片url，而后端请求微信服务器获取到小程序二维码后返回给我的是base64，所以说如何处理成功绘制base64图片是个问题。我当时想到了的解决方案就是将图片保存为本地文件不就有本地路径了，注意到一点就是如果将图片保存到本地用户文件中，那之后还要进行手动删除，如果保存到本地临时文件，那么系统是自动帮我们删除的，刚好我发现小程序的一个API，wx.getImageInfo对于网络图片产生一个get请求后可以产生临时文件路径，但需要get请求返回的是图片的二进制数据，所以我就让后端改了一下。

3. 开发微信小程序和开发web的区别
运行环境不一样：微信小程序基于微信的，在微信平台上运行；web则是运行在浏览器
wxml-> html,wxss->css
微信小程序使用了JSCore开源框架，这个框架只是实现了标准JavaScript语言，没有BOM，DOM，XMLHTTPRequest这些东西

4.使用wepy框架的优点
  1. 单文件模式，不需要每次新建一个页面就需要分别建.js,.json,.wxml,.wxss文件，比较方便
  2. 接近vue.js，组件化开发，像可以使用组件props传值，计算属性等等
  3. 使用babel进行编译，支持ES6/7的新特性，像async
  4. 对网络请求进行了promise封装，避免了回调黑洞
  5. 支持加载外部npm包
5. wepy和vue的共同点
  均有props，data，computed，components，methods，watch（wepy中为watcher）	
6. wepy和vue的区别
  1. methods属性只能声明wxml标签汇总的bind，catch事件，不能声明自定义方法
  2. 没有v-model双向绑定,使用的是脏值绑定的方式  
  
  采用“脏值检测”的方式，数据发生变更后，对于所有的数据和视图的绑定关系进行一次检测，识别是否有数据发生了改变，有变化进行处理，可能进一步引发其他数据的改变，所以这个过程可能会循环几次，一直到不再有数据变化发生后，将变更的数据发送到视图，更新页面展现。如果是手动对 ViewModel 的数据进行变更，为确保变更同步到视图，需要手动触发一次“脏值检测”。  
  3. wepy组件都是静态组件，以组件ID为标识，相同的表示共用同一个实例和数据
  4. 组件标签名不能由驼峰式命名转换成短横杆命名
  5. vue的特有组件像keep-alive（缓存不活动组件的实例），transition（过渡），wepy没有

7. js引擎--单线程机制，事件驱动机制
事件驱动机制四要素：主线程，工作线程（WebWorker），call stack（执行栈），task  queue（任务队列）  
过程描述：主线程将同步代码放入call stack执行，当遇到异步任务，如网络请求，主线程将该任务放到工作线程中进行，当异步任务完成，如请求完成，工作线程将相关回调函数推到任务队列，当执行栈中为空的时候，主线程进行一次eventloop（事件循环），将任务队列中的回调函数放到call stack执行，当执行完call stack为空，继续event loop，知道task queue为空。  
WebWorker由js宿主提供，和主线程不在同一个运行环境，不共享作用域，工作线程也不能操作window和dom
 
