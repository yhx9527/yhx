# 深入类和对象

类的构造函数(constructor)是类中的一个非常特殊的成员，它甚至没有名字


C++用了函数修饰符(function specifier)来说明构造函数的存在。


构造函数不仅在声明形式上非常特别，它的“返回值”也很特殊：在声明或定义构造函数时不能为其指定返回类型，甚至void也不行。

•类的构造函数的作用是：

–(1) 分配一个对象的数据成员的存储空间；（该功能由系统自动完成。）

–(2) 执行构造函数（体），一般是初始化一个对象的部分或全体数据成员。

构造函数定义的语法如下：

class 类名

{

public:

  类名(参数列表); //构造函数声明


};

•在需要禁止复制的情况下，类的（某种）构造函数就应该是私有的



构造函数的初始化列表是一种特殊的初始化机制，它的语法如下：

构造函数名(参数列表) [: 成员名(表达式) [, 成员名(表达式)…]]

•初始化列表的执行先于构造函数体的执行


•初始化列表中的成员必须是类的直接成员


•常量、独立引用等特殊成员，初始化只能在初始化列表中进行



类的构造函数可以被关键字explicit修饰，说明成是“显式的”，例如：

class array { public: explicit array() {...} };


一旦类的构造函数被声明为是显式的，那么一些隐式的类型转换将被阻止。



类的析构函数也是一种特殊成员，没有函数名。如果一定要给它命名，那么它的名字可以看做是在类名前加“~”，然后跟上一对空的圆括号（即没有参数）构成的，同时不能为其指定返回类型。

•析构函数不能有参数，因此不能被重载；

•不能获取析构函数的地址；

析构函数的作用是：

1.执行析构函数（一般没有具体的工作）；

2.释放对象的存储空间。（该功能由系统自动完成。）

3.释放对象占用的资源。这项工作要由程序员设定。



复制构造函数的形式化定义为：

class 类名

{


public:


  类名(const 类名&[, other parameters]); //copy constructor


};

参数必须是引用，避免陷入递归死循环调用

Rectangle::Rectangle(const Rectangle& r) : name(r.name), width(r.width), height(r.height)


{


  ++Quadrangle::counter ;


​              cout<<“in Rectangle”<<Quadrangle::counter<<endl;

}

调用复制构造函数的三种情况：

　　1.当用类一个对象去初始化另一个对象时。

　　2.如果函数形参是类对象。

　　3.如果函数返回值是类对象，函数执行完成返回调用时。



 何处会调用复制构造函数

•显式定义复制对象时，如下例所示：

–array a1;


–array a2(a1);  //调用a2的复制构造函数


–array a3 = a2; //这不是对象间的赋值，而是复制（初始化）！


•实参和形参结合时。如例中t和a结合时，将会调用形参t的复制构造函数来复制实参对象r；

•函数返回值对象（非指针和引用）时。如例中f()返回一个临时对象，这个临时对象就是用其复制构造函数从return的返回表达式t中复制而来。这个临时对象是匿名的，并且被视为常量对象。



编译器会为类合成一个隐式默认的复制构造函数。

更好的禁止复制的做法是采用C++ 1y的语法，将复制构造函数从类中“删除”，具体的语法是：

class array


{


private:


array(const array&) = delete;


//other members


};



转移复制构造函数


假设有如下代码：

array a1(10), a2(a1);

这种复制过程可以概括为三步：

第一步：为复制目标申请资源；

第二步：将资源内容从复制源复制到目标资源中；

第三步：释放复制源的资源，此后复制源失效。



自由对象通过使用new运算符来创建的。产生的对象拥有长至整个程序运行期的生命周期。


当该对象完成使命后，应该立即使用delete释放来对象（实际上调用析构函数）。

array a(10); //调用构造函数完成初始化

array b(a); //调用复制构造函数完成初始化



this是一个C++关键字


隐含存在于任一个非静态成员函数中，不能被显式声明，this指针只能出现在类的非静态成员函数中，并且常用于需要自引用的地方



友元(friend)机制


一个类的友元可以是一个外部函数，也可以是一个类。它们虽然不是该类的成员，但却能访问该类的任何成员。这显然提高了访问效率


友元分类


友元函数


友元类

例如：


class C


{


  friend int f();


};


class A


{


  class B { friend int f(); }


  C objC;


};

函数f()仅仅是类B和类C的友元，而非类A的友元。

一旦声明了类的友元，那么该类的作用域就对友元开放。也就是说，类的所有成员对友元都是可见的、可访问的


友元的作用范围仅限在直接声明它的类中。友元不能逾越嵌套类的界限而访问到外部类，除非友元同时也被显式声明为外部类的友元

•友元具有如下的特性：

•非传递性。即A是B的友元，B是C的友元，但A不一定是C的友元（除非将A声明为C的友元)；

•非对称性。即A是B的友元，但B不一定是A的友元（除非将B声明为A的友元）。



要创建一个类的对象数组，该类的构造函数必须满足下列几个条件之一：

•没有显式定义的构造函数；  


•有显式定义的构造函数，但其中有一个构造函数没有参数；


•有显式定义的构造函数，但其中有一个构造函数的所有参数都可以默认；



1.对象作为函数参数


void f(Rectangle r); //值参数

void g(Recangle *r); //指针参数

void h(Rectangle &r); //引用参数

•对象的值做参数，对形参对象的任何修改都不影响用作实参对象。


•对象引用做参数，对形参对象的任何修改就是直接对实参对象的修改。一般情况下，选择常量引用作为参数是一种非常好的选择。


对象指针做参数，对它指向的对象作任何修改就是间接对实参对象的修改；而修改参数本身将会导致参数指针指向别的对象，对实参对象没有任何影响



\2. 函数返回对象


Rectangle f(Rectangle r) { return r; } //返回值

Rectangle* g(Recangle *r) { return r; } //返回指针

Rectangle& h(Rectangle& r) { return r; } //返回引用


•函数f()返回对象r的值，这要产生一个匿名临时常量对象


•g()返回对象的指针，也就是返回对象的地址，不会引起构造函数的调用


•h()返回对象的引用，就是返回对象本身，可以作为左值使用。

•需要注意的是，在函数返回对象指针或引用时，被指向或被引用的对象必须具有超出函数作用域的生命期。



常成员函数


类的某些成员函数只是读取属性而不修改它们。这样，可以将这样的成员说明成是常成员。例如：

size_t array::size()  const { 

​	return len;

 }



嵌套类形成了一个局部作用域，包围类的成员在这个作用域中是不可见的。下面的f()定义是错误的：

void encircle::nested::f() 


{ 


  i = 0; //error，包围类的成员对嵌套类是不可见的

  encircle::i = 0; //error，i不是encircle类的静态成员

} 


反过来，嵌套类的作用域对包围类来说也是封闭的。

嵌套类可以被声明为包围类的友元。这样，嵌套类可以通过包围类的对象直接访问其所有成员。例如：

class encircle


{


private:


​    int i;





​    friend class nested; //嵌套类成为包围类的友元

​    class nested


​    {


​    public:


​        void g(encircle& e) { e.i = 0; } //OK


​    };


};
