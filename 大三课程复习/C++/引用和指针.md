# 详解c++ 引用（reference）与 指针（pointer）的区别与联系

#### 搬运

引用(reference) 与指针（pointer）之间有什么区别和联系呢？我相信，对于很多初学c++的程序猿来说，不是一件简单的事.那么在c++中，引用与指针到底有什么联系和区别呢？要弄清楚这个问题，我们必须明白 ： 
1.什么是引用？ 
2.怎样使用引用？ 
3.引用的使用场合？ 
4.引用与指针有什么联系和区别？ 
下面容小生一一为各位详细道来？ 
1.什么是引用？ 
要明白什么是引用，我们就必须明白c++ 为什么要引入引用? c++ 在某些程度来说，是c的一个扩充和改善，我们知道，c程序一个非常显著的优势就是c程序的执行效率，而c高效执行的原因就是对指针的操作（直接对内存进行操作），小生相信，对于绝大部分c程序员来说，对指针是又爱又恨，爱它，是因为 ，c语言指针所带来的效率是其它程序无法比拟的，恨它，我想，小生也没必要多说了，对指针操作不慎所带来的bug，相信大家都深有体会吧，而c++ 语言设计之初，c++委员会，即想保持c指针的高效，又不想有指针的缺点，所以就引入了引用这一概念，但是后来，却发现，指针没法被引用取代。好了，说了这么多，那到底什么是引用呢？ 
引用（reference）： 引用只是别名，不是实体类型（也就是说c++编译器不为引用单独分配内存空间），对一个对象的引用，就是直接对这个对象的操作。 
`int a = 3; //定义了一个整形变量a，并且赋初值3 
int & ra = a;//定义了一个引用 ra ,ra与变量占有同一块内存空间 
a = 4; //此时 a 与ra 的值都为 4； 
ra = 5;//此时 a 与 ra的值都是5；

2.怎样使用引用？ 
（1）引用必须初始化(引用必须指向所引用的对象)

int a = 3;
int& ra = a;
int &b ;//错误，引用必须初始化
const int &b = 10;//正确对字面值常量10的引用

```
int a = 3;
int& ra = a;
int &b ;//错误，引用必须初始化
const int &b = 10;//正确对字面值常量10的引用
```



（2）引用不能为空

int &b ;//错误，引用不能为空必须有所引用的对象

```
int &b ;//错误，引用不能为空必须有所引用的对象

```



(3)引用不能更换目标

```
#include<iostream>
using namespace std;
int main(void){
    int a = 3;
    int b = 4;
    int& ra = a;
    // int& ra = b;//错误，多次初始化

    return 0;
}

```



3.引用的使用场合？ 
（1）引用型参数（函数形参只是实参的别名，也就是说形参和实参是同一个对象） 
使用引用型参数有两个好处：（1）因为函数形参和实参是同一个对象，也就不存在对象复制，避免了对象的开销。（2）可以在修改形参的同时对实参的修改。 
当然了，为了避免函数对原来实参的意外修改我们可以 用const 对引用加以修饰 也就是传常引用。传常引用有两个优势（1）因为不存在拷贝构造所以，可以提高c++程序的执行效率（2）避免对象切割问题。关于这点的详细讨论可以看effective c++ 。 
（2）引用型返回值 
从函数中返回引用，一定要保证在函数返回以后，被引用的目标一直有效，也就是不能返回函数体内的局部对象的引用，大家都知道， 局部对象离开作用域就会被析构掉，所以不能返回对函数体内的局部对象的引用。

4.引用与指针的联系与区别？ 
啰嗦了这么久 ，现在终于回到我们的正题，引用与指针到底有什么区别和联系了，其实，在c++底层中，引用是通过指针实现的。也就是说，在实现层面上，引用就是指针，但是从c++的程序语言层面上来说，引用不是实体类型（不为引用单独分配内存空间）因此，引用与指针之间的区别主要体现在以下几个方面： 
（1）存在空指针，但是不存在空引用

```
void * a;//空指针，合法
//void& b;//空引用，不合法
```



（2）虽然c++编译器会警告，但是指针可以不初始化，而引用必须初始化，并且，引用的目标一旦确定，后面不能再更改，指针可以更改其指向的目标。

```
#include<iostream>
using namespace std;

int main(void){
    void * a;
    //void& b;

    int x = 1;
    int y = 2;
    int z = 3 ;
    //指针c可以不初始化，可以更改其指向的目标，
    int * c;
    c = &x;
    c = &y;

    //引用必须初始化，不可以更改其指向的目标
    //int& ra ;//报错，ra 必须要指定初值
    int & ra = x;
    ra = y;//这里只是把y的值赋给 ra 也就是x 而并不是使引用的目标由 对x的引用到对y的引用


    return 0;
}

```



（3）存在指针数组 ，不存在引用数组

```

```



5.学海拾贝 

大家在使用引用和指针时，只要记住一点就够了，在c++底层中，引用是通过指针实现的，所以，在实现层面上来说，引用就是指针，但是在c++语法上来说，c++编译器并不为引用类型分配内存，所以引用不能为空，必须被初始化，一旦初始化不能更改引用对象。所有对引用的操作都是对原始对象的操作



### 原文链接

[详解c++ 引用（reference）与 指针（pointer）的区别与联系](https://blog.csdn.net/tianxiaolu1175/article/details/46889523)

