# 函数

参数结合的三种方式

1)传值

C++采用传值(call by value)方式进行参数传递。

在参数结合时，形参是实参的一个复制品

2)传指针

传递指针实际上仍属于传值的范畴：形参指针是实参指针的拷贝。不过，这两个指针指向了同一个单元。因此，通过这两个指针的任何一个都可以间接地改变实参的值。 

3)传引用

实参和形参结合的第三种也是最好的一种方法就是传递引用。我们都知道，引用是一个单元的别名。这种别名结合也适用于参数结合。当形参是一个引用时，那么在函数内部，形参就是实参的别名，换句话说，形参就是实参本身，因此对形参的改变就会直接改变实参。



const作用于参数

使用指针和引用参数具有实参被更改的潜在“危险”。为了避免这种危险，可以给形参加上const约束，这是形参/实参成为只读参数，从而避免了被更改的问题。例如：

void func(const int *pi)

{

  int a = *pi;  //正确

  *pi = 0;  //错误，因为pi指向的单元被视为常量

  pi = &a;  //正确，因为pi不是常量指针

}



### 返回值

\1. 函数返回值类型

函数返回一个值类型，实际上是将返回的值放到一个临时对象中

\3. 函数返回引用

函数返回引用，实际上返回的是一个对象，是个左值，只不过是匿名的



•函数重载有以下禁忌：

–仅返回值类型不同而其它部分相同的函数不能重载；

–同一个作用域中的函数不能原型一致地重载。如果要重载，那么必须在参数列表上有所不同。



函数重载只以参数作为参考点，因此这里就对重载函数的参数进行一些说明

1)用typedef定义的类型别名与原类型等效。例如：

typedef int INT;

void f(int i) { … }  //函数定义

void f(INT i) { … } //错误，重定义f函数

2)指针和数组参数是等效的。例如：

void g(int *);

void g(int []);  //与g(int *)一样

void g(int [5]);  //与g(int *)一样

3)函数参数和函数指针参数是等效的。例如：

void h(int ());

void h(int (*)());  //与h(int ())一样

4)在函数调用时编译器无法区分cv-修饰符。例如：

void k(int) { … }

void k(const int) { … } //错误，重定义k(int)

5)不同函数的对应参数仅是默认参数的不同时，它们是等效的。例如：

void p(int i = 0);

void p();

void q() {   p(); }  //错误，调用的是p(int)还是p()?



C++的存储类修饰符有五种，分别是：

•auto和register：修饰的对象是局部的

•extern：修饰的对象名出现在同一应用的不同文件中

•static：修饰的对象是静态的

•mutable：去掉包含该成员的常量类对象作用于这个成员身上的const约束




