# 继承和派生

继承基类的所有成员


派生类实际上包含了它所有基类中除了构造函数、析构函数和赋值运算符之外的所有成员

2.改造基类成员


方式一 通过不同的派生方式改造基类成员


方式二 就是在派生类中声明与基类成员同名的成员来覆盖基类成员


3.增加新的成员

根据派生类的实际特征，增加不同于基类的成员

•段描述符用于控制类的成员在类外的可访问性，例如私有成员在类外是不可访问的；

•而继承中的访问控制描述符则描述了基类的成员将被放在派生类的哪个段中，例如私有继承将基类的所有成员放在了派生类的私有段中

基类的protected成员是这样一类成员：它们无论在基类还是在派生类外都无法被访问到，但在派生类中却可以被直接访问。

C++规定，在整个继承树中，所有后代都和基类共享唯一的静态成员。换句话说，就是无论存在多少个基类和/或派生类对象，只要其中一个改变了静态成员的值，那么这个改变将反映到其它所有的对象中。这严格遵循了静态成员是属于类而非对象的原则。

正是由于这个原因，对静态成员的访问都采用如下限定方式：

基类名::静态成员名

在 C++ 中，派生类构造函数的声明为:

派生类构造函数(参数列表)：基类(参数列表)，成员(参数列表)，… 

{  …  }

在派生类的构造函数执行过程中，遵循先父辈(基类)，再客人(对象成员)，后自己(派生类)的顺序。如果基类使用缺省构造函数或不带参数的构造函数，那么派生类构造函数声明中“:”后面的“基类(参数列表)”一项可以省去，但是派生类构造函数执行时仍然隐含地调用基类的构造函数



. 派生类对象和基类对象间的直接赋值

设有如下对象定义：

felid f;

carnivore c;

那么赋值语句

c = f;

是合法的。

这种赋值将派生类对象中属于基类的部分赋给了指定的基类对象，而只属于派生类对象的部分被舍弃了。这种现象称为“切片(slicing)”



基类指针直接赋值给派生类指针是非法的：

carnivore c;

felid *q = &c; //非法

如果一定要这么做，那么也可以使用类型强制转换运算符：

q = dynamic_cast<felid *>(&c);
