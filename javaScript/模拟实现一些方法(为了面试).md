# js的一些方法的模拟实现

### call的模拟实现

首先应知道call是定义在函数原型中的方法，然后假如fn函数调用了call方法，传入的是ctx对象，那就相当于给ctx对象增加了一个fn函数，因为ctx.fn()这样调用函数，那函数中的this不就是ctx对象了吗。模拟步骤如下：

1. 首先传入的ctx如果是null或者undefined，那么我们默认为window
2. 然后给ctx增加一个fn函数
3. 接着还要接收传给fn函数的参数，我们使用一个数组来存arguments[i]表达式。因为调用call之后fn函数是立即执行的，而相应的参数要传给fn函数我们总不能使用字符串来传吧，这样是不执行的，而且我们也不知道具体的参数个数是多少。这里使用到了eval()函数，该函数将字符串都解析成表达式或变量来执行。
4. 对于fn函数执行完后的结果我们接收，然后删除ctx的fn函数，因为是一次性的
5. 最后返回改变了执行环境的fn函数执行后的结果

```
Function.prototype.myCall=function(ctx){
    var ctx = ctx || window;
    ctx.fn = this;
    var args = [];
    for(var i=1,len=arguments.length;i<len;i++){
        args.push('arguments['+i+']');
    }
    var result = eval('ctx.fn('+args+')');
    delete ctx.fn
    return result;
}
```



### apply的模拟实现

和call步骤差不多，差别在于apply接收的给fn函数的参数是数组的形式。还是利用eval()来实现内部调用fn

对于apply的第二个参数只要是类数组对象就可以了

类数组对象：拥有若干索引属性和length属性的对象，不能使用数组特有的方法，如forEach，join等

```
Function.prototype.myApply=function(ctx,arr){
    var ctx = ctx || window;
    var result;
    ctx.fn = this;
    if(!arr){
        result = ctx.fn();
    }else{
        var args=[];
        for(var i=0;i<arr.length;i++){
            args.push('arr['+i+']');
        }
        result = eval('ctx.fn('+args+')');
    }
    delete ctx.fn
    return result;
}
```



### 参考链接

1. [JavaScript深入之call和apply的模拟实现](https://github.com/mqyqingfeng/Blog/issues/11)